{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 圖像比對"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from keras.applications.vgg16 import VGG16\n",
    "from keras.preprocessing import image\n",
    "from keras.applications.vgg16 import preprocess_input, decode_predictions\n",
    "import numpy as np\n",
    "import os\n",
    "import sys\n",
    "# 計算相似矩陣\n",
    "def cosine_similarity(ratings):\n",
    "    sim = ratings.dot(ratings.T)\n",
    "    if not isinstance(sim, np.ndarray):\n",
    "        sim = sim.toarray()\n",
    "    norms = np.array([np.sqrt(np.diagonal(sim))])\n",
    "    return (sim / norms / norms.T)\n",
    "    \n",
    "def main():\n",
    "    # 自 images 目錄找出所有 JPEG 檔案    \n",
    "    y_test=[]\n",
    "    x_test=[]\n",
    "    for img_path in os.listdir(\"pic\"):\n",
    "        if img_path.endswith(\".jpg\"):\n",
    "            img = image.load_img(\"pic/\"+img_path, target_size=(224, 224))\n",
    "            y_test.append(img_path[0:4])\n",
    "            x = image.img_to_array(img)\n",
    "            x = np.expand_dims(x, axis=0)\n",
    "            if len(x_test) > 0:\n",
    "                x_test = np.concatenate((x_test,x))\n",
    "            else:\n",
    "                x_test=x\n",
    "    \n",
    "    # 轉成 VGG 的 input 格式\n",
    "    x_test = preprocess_input(x_test)\n",
    "    model = VGG16(weights='imagenet', include_top=False) \n",
    "    # 萃取特徵\n",
    "    features = model.predict(x_test)\n",
    "    # 計算相似矩陣\n",
    "    features_compress = features.reshape(len(y_test),7*7*512)\n",
    "    sim = cosine_similarity(features_compress)\n",
    "    # 依命令行參數，取1個樣本測試測試\n",
    "    inputNo = int(sys.argv[1]) # tiger, np.random.randint(0,len(y_test),1)[0]\n",
    "    top = np.argsort(-sim[inputNo], axis=0)[1:3]\n",
    "\n",
    "    # 取得最相似的前2名序號\n",
    "    recommend = [y_test[i] for i in top]\n",
    "    print(sim)\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n",
    "\n",
    "\n"
   ]
  },
 
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 影像辨識-來源"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from tqdm import tqdm\n",
    "from sklearn.model_selection import train_test_split\n",
    "import keras\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Dropout, Flatten\n",
    "from keras.layers import Conv3D,Conv2D, MaxPooling2D\n",
    "from keras.utils import to_categorical\n",
    "from keras.preprocessing import image\n",
    "%matplotlib inline\n",
    "\n",
    "train = pd.read_excel('test.xlsx',sheet_name='來源')\n",
    "\n",
    "#讀取與處理圖片數據，400長,400寬,3維度3D\n",
    "train_image = []\n",
    "for i in tqdm(range(train.shape[0])):\n",
    "    img = image.load_img(r'C:\\Users\\tiffany chen\\OneDrive\\桌面\\報告們\\歐老師\\論文\\test/'+train['Id'][i]+'.jpg',\n",
    "                         target_size=(400,400,3))\n",
    "    img = image.img_to_array(img)\n",
    "    img = img/255\n",
    "    train_image.append(img)\n",
    "X = np.array(train_image)\n",
    "\n",
    "#刪除id、name、genre這三欄\n",
    "y = np.array(train.drop(['Id','name', 'Genre'],axis=1))\n",
    "\n",
    "#檢查模型，將20%的圖片取出來\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, test_size=0.2)\n",
    "\n",
    "#定義模型架構\n",
    "model = Sequential()#選擇模型，序貫模型\n",
    "#建構網路模型\n",
    "model.add(Conv2D(filters=16, kernel_size=(5, 5), activation=\"relu\", input_shape=(400,400,3))) \n",
    "#2D卷積層，filters輸出空間的維數，kernel_size指定尺寸，activation代表激活函數\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=32, kernel_size=(5, 5), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=64, kernel_size=(5, 5), activation=\"relu\"))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=64, kernel_size=(5, 5), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Flatten())\n",
    "model.add(Dense(128, activation='relu'))#代表隱藏層節點\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(64, activation='relu'))\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(3, activation='sigmoid'))#代表輸出結果的標籤個數，3個標籤就是3\n",
    "model.summary()#把模型列印出來\n",
    "\n",
    "#編譯模型。使用binary_crossentropy作為損失函數，並使用ADAM作為優化器\n",
    "model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n",
    "\n",
    "#訓練，epoch代表訓練次數\n",
    "model.fit(X_train, y_train, epochs=50, validation_data=(X_test, y_test), batch_size=25)\n",
    "\n",
    "#一次預測多個圖片\n",
    "for x in range(1,31):\n",
    "    img = image.load_img('t'+str(x)+'.jpg',target_size=(400,400,3))\n",
    "    img = image.img_to_array(img)\n",
    "    img = img/255\n",
    "    #預測海報類型。該模型將告訴我們每種類型的概率，然後我們將從中得出前3個預測。\n",
    "    classes = np.array(train.columns[3:]) #跳過前3欄的意思\n",
    "    proba = model.predict(img.reshape(1,400,400,3))\n",
    "    top_3 = np.argsort(proba[0])[:-4:-1]#可以調想預測多少個類別，要調第一個負值\n",
    "    for i in range(1):#調預測類別數\n",
    "        print(\"{}\".format(classes[top_3[i]])+\" ({:.3})\".format(proba[0][top_3[i]]))#.3代表小數點後幾位\n",
    "        #plt.imshow(img)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 影像辨識-特徵"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from tqdm import tqdm\n",
    "from sklearn.model_selection import train_test_split\n",
    "import keras\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Dropout, Flatten\n",
    "from keras.layers import Conv3D,Conv2D, MaxPooling2D\n",
    "from keras.utils import to_categorical\n",
    "from keras.preprocessing import image\n",
    "%matplotlib inline\n",
    "\n",
    "train = pd.read_excel('test.xlsx',sheet_name='特徵')\n",
    "\n",
    "#讀取與處理圖片數據，400長,400寬,3維度3D\n",
    "train_image = []\n",
    "for i in tqdm(range(train.shape[0])):\n",
    "    img = image.load_img(r'C:\\Users\\tiffany chen\\OneDrive\\桌面\\報告們\\歐老師\\論文\\test/'+train['Id'][i]+'.jpg',\n",
    "                         target_size=(400,400,3))\n",
    "    img = image.img_to_array(img)\n",
    "    img = img/255\n",
    "    train_image.append(img)\n",
    "X = np.array(train_image)\n",
    "\n",
    "#刪除id、name、genre這三欄\n",
    "y = np.array(train.drop(['Id','name', 'Genre'],axis=1))\n",
    "\n",
    "#檢查模型，將20%的圖片取出來\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, test_size=0.2)\n",
    "\n",
    "#定義模型架構\n",
    "model = Sequential()#選擇模型，序貫模型\n",
    "#建構網路模型\n",
    "model.add(Conv2D(filters=16, kernel_size=(5, 5), activation=\"relu\", input_shape=(400,400,3))) \n",
    "#2D卷積層，filters輸出空間的維數，kernel_size指定尺寸，activation代表激活函數\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=32, kernel_size=(5, 5), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=64, kernel_size=(5, 5), activation=\"relu\"))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=64, kernel_size=(5, 5), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Flatten())\n",
    "model.add(Dense(128, activation='relu'))#代表隱藏層節點\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(64, activation='relu'))\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(8, activation='sigmoid'))#代表輸出結果的標籤個數，3個標籤就是3\n",
    "model.summary()#把模型列印出來\n",
    "\n",
    "#編譯模型。使用binary_crossentropy作為損失函數，並使用ADAM作為優化器\n",
    "model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n",
    "\n",
    "#訓練，epoch代表訓練次數\n",
    "model.fit(X_train, y_train, epochs=50, validation_data=(X_test, y_test), batch_size=25)\n",
    "\n",
    "#一次預測多個圖片\n",
    "for x in range(1,31):\n",
    "    img = image.load_img('t'+str(x)+'.jpg',target_size=(400,400,3))\n",
    "    img = image.img_to_array(img)\n",
    "    img = img/255\n",
    "    #預測海報類型。該模型將告訴我們每種類型的概率，然後我們將從中得出前3個預測。\n",
    "    classes = np.array(train.columns[3:]) #跳過前3欄的意思\n",
    "    proba = model.predict(img.reshape(1,400,400,3))\n",
    "    top_3 = np.argsort(proba[0])[:-4:-1]#可以調想預測多少個類別，要調第一個負值\n",
    "    for i in range(1):#調預測類別數\n",
    "        print(\"{}\".format(classes[top_3[i]])+\" ({:.3})\".format(proba[0][top_3[i]]))#.3代表小數點後幾位\n",
    "        #plt.imshow(img)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 影像辨識-類型"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from tqdm import tqdm\n",
    "from sklearn.model_selection import train_test_split\n",
    "import keras\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Dropout, Flatten\n",
    "from keras.layers import Conv3D,Conv2D, MaxPooling2D\n",
    "from keras.utils import to_categorical\n",
    "from keras.preprocessing import image\n",
    "%matplotlib inline\n",
    "\n",
    "train = pd.read_excel('test.xlsx',sheet_name='類型')\n",
    "\n",
    "#讀取與處理圖片數據，400長,400寬,3維度3D\n",
    "train_image = []\n",
    "for i in tqdm(range(train.shape[0])):\n",
    "    img = image.load_img(r'C:\\Users\\tiffany chen\\OneDrive\\桌面\\報告們\\歐老師\\論文\\test/'+train['Id'][i]+'.jpg',\n",
    "                         target_size=(400,400,3))\n",
    "    img = image.img_to_array(img)\n",
    "    img = img/255\n",
    "    train_image.append(img)\n",
    "X = np.array(train_image)\n",
    "\n",
    "#刪除id、name、genre這三欄\n",
    "y = np.array(train.drop(['Id','name', 'Genre'],axis=1))\n",
    "\n",
    "#檢查模型，將20%的圖片取出來\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, test_size=0.2)\n",
    "\n",
    "#定義模型架構\n",
    "model = Sequential()#選擇模型，序貫模型\n",
    "#建構網路模型\n",
    "model.add(Conv2D(filters=16, kernel_size=(5, 5), activation=\"relu\", input_shape=(400,400,3))) \n",
    "#2D卷積層，filters輸出空間的維數，kernel_size指定尺寸，activation代表激活函數\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=32, kernel_size=(5, 5), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=64, kernel_size=(5, 5), activation=\"relu\"))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(filters=64, kernel_size=(5, 5), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Flatten())\n",
    "model.add(Dense(128, activation='relu'))#代表隱藏層節點\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(64, activation='relu'))\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(12, activation='sigmoid'))#代表輸出結果的標籤個數，3個標籤就是3\n",
    "model.summary()#把模型列印出來\n",
    "\n",
    "#編譯模型。使用binary_crossentropy作為損失函數，並使用ADAM作為優化器\n",
    "model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n",
    "\n",
    "#訓練，epoch代表訓練次數\n",
    "model.fit(X_train, y_train, epochs=50, validation_data=(X_test, y_test), batch_size=25)\n",
    "\n",
    "#一次預測多個圖片\n",
    "for x in range(1,31):\n",
    "    img = image.load_img('t'+str(x)+'.jpg',target_size=(400,400,3))\n",
    "    img = image.img_to_array(img)\n",
    "    img = img/255\n",
    "    #預測海報類型。該模型將告訴我們每種類型的概率，然後我們將從中得出前3個預測。\n",
    "    classes = np.array(train.columns[3:]) #跳過前3欄的意思\n",
    "    proba = model.predict(img.reshape(1,400,400,3))\n",
    "    top_3 = np.argsort(proba[0])[:-4:-1]#可以調想預測多少個類別，要調第一個負值\n",
    "    for i in range(1):#調預測類別數\n",
    "        print(\"{}\".format(classes[top_3[i]])+\" ({:.3})\".format(proba[0][top_3[i]]))#.3代表小數點後幾位\n",
    "        #plt.imshow(img)"
   ]
  }
 ],
